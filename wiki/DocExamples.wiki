#summary Examples of how to add doc comments to your source code.

= Functions =

  * Use the `-a` option to have all functions and their parameters appear in your output.

{{{
function recast(employeeId, newRole) {
}

refresh = function(record) {
}
}}}

  * Alternatively add a description of the function. Documented functions always appear in the output, even withou the `-a` option.

{{{
/** Change the role of the employee. */
function recast(employeeId, newRole) {
}
}}}

= Nested Functions =

  * Use the `-a` option to have all nested functions and their parameters appear in your output.

{{{
record = {
    remove: function() {
    }
};

record.refresh = function(record) {
}
}}}

  * Optionally add a description of the nested function.

{{{
record = {
    /** Remove the record. */
    remove: function() {
    }
};
}}}

  * Same for arbitrarily deeply nested functions.

{{{
record = {
    row: {
         field: {
            /** Remove the record. */
            remove: function() {
            }
        }
    }
};
}}}

= Underscored Functions =

  * The `-a` option will generally include all functions in your output, but a special exception is made for functions named with a leading underscore. By convention an underscored name means a function is for internal use only, therefore not part of the public API. If you wish *all* functions, even underscored functions, to appear in your output use the `-A` option instead.

{{{
function _peek(record) {
}
}}}

= Ignoring Functions =

  * To force a function to be ignored, when it would otherwise appear in the output, use the `@ignore` tag.

{{{
/** @ignore */
function hide(file) {
}
}}}

= Constructors =

  * Use the `@constructor` tag to indicate a function is a constructor.

{{{
/** @constructor */
function RecordSet() {
}
}}}

  * Optionally add a description of the constructor.

{{{
/**
 * A collection of records.
 * @constructor
 */
function RecordSet() {
}
}}}

= Methods =

  * Use the `-a` option to have all nested functions, including methods, and their parameters appear in your output.

{{{
/** @constructor */
function RecordSet() {
    this.getRecords = function(){
    }
}
}}}

  * Optionally add a description of the method.

{{{
/** @constructor */
function RecordSet() {
    /** Get all the records. */
    this.getRecords = function(){
    }
}
}}}

= Properties =

  * The `-a` option does not apply to properties. Only documented properties appear in the output.

{{{
/** @constructor */
function RecordSet(id) {
    /** The record set's id number */
    this.id = id;
}
}}}

  * Optionally add more information about the property.

{{{
/** @constructor */
function RecordSet(id) {
    /**
     * The record set's id number.
     * @type number
     */
    this.id = id;
}
}}}

  * Alternatively you can describe the property in the constructor's comment.
 
{{{
/**
 * @constructor
 * @property {number} id The record set's id number.
 */
function RecordSet(id) {
    this.id = id;
}
}}}

= Properties that are Methods =

  * In practice a "method" is just a property whose value is set to a function. Because !JavaScript does not enforce types it's possible to set a property to either a function or non-function at runtime. In cases where it isn't obvious from the source code what a property is going to be set to, use the `@function` tag to make it clear.

{{{
/** @constructor */
function RecordSet(f) {
    /** @function */
    this.write = f;
}
}}}

= Variables =

  * The `-a` option does not apply to variables. Only documented variables appear in the output.

{{{
/** The maximum number of records. */
var LIMIT = 99;
}}}

  * The same if the value is an object literal, or one of the nested values.

{{{
/** The maximum number of records. */
var CONFIG = {
    defaults: {
        /** The default format. */
        format: "XML"
    }
};
}}}

= File Overview =

  * You can create a doc comment that applies to the _entire file_ by using the `@fileOverview` tag.
  * The human-readable name of the library can be set by using the `@library` tag. This name will be used in index listings, otherwise the filename will be used.

{{{
/**
 * @fileOverview A collection of functions for records.
 * @library Record Keeper
 */
 
/** 
 * Gets the current record. 
 */
function getRecord(){
}
}}}

= Virtual Objects =

  * In some cases you want to document an object that either isn't in the source code, or is written in a way that can't be recognized by the !JsDoc parser. Use the `@name` tag to provide the name of the object.
  * Note that this technique will _force_ the comment to be treated separately from the code around it. So, even if there is a recognizable function after the comment, that function will not be treated as connected to the comment in any way.

{{{
/**
 * The file index.
 * @name fileIndex
 */
}}}

  * You can add other tags, just like an ordinary doc comment. If the thing you are documenting is a function add the `@function` tag, if it is a constructor add the `@constructor` tag. If neither of these are found it will be assumed to be an object (variable).

{{{
/**
 * A file indexer.
 * @name Indexer
 * @constructor
 */
}}}

  * If the virtual object is a method it must be tagged with `@function` and additionally a `@memberOf` tag, indicating the name of the parent object.

{{{
/**
 * Get the file's index.
 * @name getIndex
 * @function
 * @memberOf Indexer
 */
}}}

= Namespaces =

  * In complex cases it may be impossible for the !JsDoc parser to determine the scope and thus the full name of objects. In these cases the `@namespace` tag tells the parser what the parent-scope is of an object.
  * The `@namespace` tag _must_ precede an object literal. Within that object any properties will be the applied to the given namespace.

{{{
framework.createClass(
    "FileWatcher.Widget",
    /** @namespace FileWatcher.Widget */
    {
        /** Set up the widget. */
        initialize: function(container, args) {
        }
    }
);
}}}

  * In the above example the parser will find a function named: `FileWatcher.Widget.initialize`.
